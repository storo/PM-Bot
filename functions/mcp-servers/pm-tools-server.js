const { McpServer } = require("@modelcontextprotocol/sdk/server/mcp.js");const { StdioServerTransport } = require("@modelcontextprotocol/sdk/server/stdio.js");const { z } = require("zod");const admin = require('firebase-admin');if (!admin.apps.length) {  admin.initializeApp();}const db = admin.firestore();const mcpServer = new McpServer({  name: "pm-tools",  version: "1.0.0"});mcpServer.registerTool("updateTaskStatus", {  title: "Actualizar Estado de Tarea",  description: "Actualiza el estado de una tarea especÃ­fica",  inputSchema: z.object({    taskId: z.string().describe("ID de la tarea a actualizar"),    status: z.enum(['todo', 'in_progress', 'done', 'blocked']).describe("Nuevo estado de la tarea"),  })}, async ({ taskId, status }) => {  try {    const taskRef = db.collection('tasks').doc(taskId);    const taskDoc = await taskRef.get();    if (!taskDoc.exists) {      return {        content: [{          type: "text",          text: `âŒ Tarea con ID ${taskId} no encontrada`        }],        isError: true      };    }    await taskRef.update({      status,      updatedAt: admin.firestore.FieldValue.serverTimestamp()    });    return {      content: [{        type: "text",        text: `âœ… Estado de la tarea "${taskDoc.data().title}" actualizado a ${status}`      }]    };  } catch (error) {    return {      content: [{        type: "text",        text: `âŒ Error al actualizar estado de tarea: ${error.message}`      }],      isError: true    };  }});mcpServer.registerTool("assignTask", {  title: "Asignar Tarea",  description: "Asigna una tarea a un usuario especÃ­fico",  inputSchema: z.object({    taskId: z.string().describe("ID de la tarea a asignar"),    assigneeId: z.string().describe("ID del usuario al que se asignarÃ¡ la tarea"),  })}, async ({ taskId, assigneeId }) => {  try {    const taskRef = db.collection('tasks').doc(taskId);    const taskDoc = await taskRef.get();    if (!taskDoc.exists) {      return {        content: [{          type: "text",          text: `âŒ Tarea con ID ${taskId} no encontrada`        }],        isError: true      };    }    const userDoc = await db.collection('users').doc(assigneeId).get();    if (!userDoc.exists) {      return {        content: [{          type: "text",          text: `âŒ Usuario con ID ${assigneeId} no encontrado`        }],        isError: true      };    }    await taskRef.update({      assigneeId,      updatedAt: admin.firestore.FieldValue.serverTimestamp()    });    return {      content: [{        type: "text",        text: `âœ… Tarea "${taskDoc.data().title}" asignada a ${userDoc.data().fullName}`      }]    };  } catch (error) {    return {      content: [{        type: "text",        text: `âŒ Error al asignar tarea: ${error.message}`      }],      isError: true    };  }});mcpServer.registerTool("listTasksByProjectAndStatus", {  title: "Listar Tareas por Proyecto y Estado",  description: "Lista tareas de un proyecto filtradas por estado",  inputSchema: z.object({    projectId: z.string().describe("ID del proyecto"),    status: z.enum(['todo', 'in_progress', 'done', 'blocked']).optional().describe("Estado de la tarea"),  })}, async ({ projectId, status }) => {  try {    let tasksQuery = db.collection('tasks').where('projectId', '==', projectId);    if (status) {      tasksQuery = tasksQuery.where('status', '==', status);    }    const tasksSnapshot = await tasksQuery.get();    const tasks = tasksSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));    if (tasks.length === 0) {      return {        content: [{          type: "text",          text: `No se encontraron tareas ${status ? 'en estado ' + status : ''} para el proyecto.`        }]      };    }    const taskList = tasks.map(task => `- ${task.title} (Estado: ${task.status}, Asignado: ${task.assigneeId || 'N/A'})`).join('\n');    return {      content: [{        type: "text",        text: `ğŸ“‹ Tareas para el proyecto:\n${taskList}`      }]    };  } catch (error) {    return {      content: [{        type: "text",        text: `âŒ Error al listar tareas: ${error.message}`      }],      isError: true    };  }});async function main() {  const transport = new StdioServerTransport();  await mcpServer.connect(transport);  console.log("PM Tools MCP Server running...");}main().catch(console.error);